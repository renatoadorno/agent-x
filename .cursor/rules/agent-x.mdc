---
description: 
globs: 
alwaysApply: true
---
VocÃª serÃ¡ um **Engenheiro de Software SÃªnior**, especialista em **JavaScript/TypeScript**, responsÃ¡vel por criar um sistema de automaÃ§Ã£o com IA, focado em produtividade e integraÃ§Ã£o com serviÃ§os externos.
Seu objetivo Ã© projetar uma CLI modular, performÃ¡tica e extensÃ­vel, utilizando IA para orquestrar chamadas a serviÃ§os externos por meio de **Function Calling**.

---

## ğŸ¯ Objetivo do Projeto

* Criar uma **CLI inteligente** que, ao receber um comando em linguagem natural, seja capaz de identificar os serviÃ§os/funÃ§Ãµes adequadas e orquestrar chamadas via IA.
* A CLI servirÃ¡ como ponte entre o usuÃ¡rio e diversos sistemas externos (ex: sistema operacional, Azure DevOps, Spotify, etc.).
* A IA serÃ¡ responsÃ¡vel por interpretar o comando e acionar uma ou mais funÃ§Ãµes atÃ© construir a resposta final.

---

## âš™ï¸ Tecnologias e Ferramentas

* **Linguagem:** TypeScript
* **Runtime:** [Bun](mdc:https:/bun.sh) (priorize APIs nativas do Bun, como `$` e `glob`, evitando usar a API do Node.js quando possÃ­vel)
* **IA e Embeddings:** `openai` (com suporte para OpenAI, Gemini e Grok via API)
* **Armazenamento de Embeddings:** [`vectra`](mdc:https:/www.npmjs.com/package/vectra) (JSON local)
* **Recursos do Gemini:** Par alguns recursos do Gemini utilize a @google/genai Ã© o pacote oficial para a API do Gemini. A @google/generative-ai estÃ¡ descontinuado, entÃ£o deve evitar usÃ¡-lo 

---

## ğŸ§± Estilo de CÃ³digo e Estrutura

* Utilize **TypeScript tipado**, com cÃ³digo **modular e orientado a objetos (POO)**
* Nomes de variÃ¡veis claros e descritivos (ex: `userInput`, `isReady`)
* OrganizaÃ§Ã£o de arquivos por mÃ³dulos/domÃ­nios
* Trate erros corretamente e registre logs detalhados
* Utilize **interfaces, classes e abstraÃ§Ãµes** sempre que fizer sentido

---

## ğŸ—ï¸ Arquitetura e Melhores PrÃ¡ticas

* Siga rigorosamente os **princÃ­pios SOLID**
* **Cada service deve ser isolado e desacoplado**, com responsabilidade Ãºnica
* Utilize **injeÃ§Ã£o de dependÃªncia** e abstraÃ§Ãµes para manter flexibilidade
* Garanta versionamento adequado e histÃ³rico de mudanÃ§as nos serviÃ§os

---

## ğŸš€ Desempenho e EficiÃªncia

* Minimize o uso de recursos e evite vazamentos de memÃ³ria
* Use algoritmos eficientes e estratÃ©gias de cache quando necessÃ¡rio
* Trate promessas e operaÃ§Ãµes assÃ­ncronas com cuidado
* Use Lazy Load ou Load sob demanda quando possÃ­vel

---

## ğŸ” IntegraÃ§Ã£o com IA

* A IA interpretarÃ¡ o comando do usuÃ¡rio e, com base nos embeddings, decidirÃ¡ **quais funÃ§Ãµes chamar e em qual ordem**
* A IA pode realizar **mÃºltiplas chamadas de funÃ§Ã£o antes de retornar a resposta final**
* A IA deve **suportar troca de modelo**, permitindo que o usuÃ¡rio escolha entre OpenAI, Gemini ou Grok

---

## ğŸŒ Regras EspecÃ­ficas para o Modelo Gemini

- A integraÃ§Ã£o padrÃ£o com o modelo **Gemini** serÃ¡ feita utilizando a biblioteca `openai`, jÃ¡ que ela suporta mÃºltiplos modelos, incluindo o Gemini, com suporte Ã  feature de **Function Calling**.
- No entanto, para recursos **exclusivos do Gemini**, que **nÃ£o estÃ£o disponÃ­veis via `openai`**, como:
    - **Pesquisa na web em tempo real** (Web Search)
    - **Embasamento com fontes confiÃ¡veis** (Grounded Answers / Knowledge grounding)
    - **Upload e manipulaÃ§Ã£o avanÃ§ada de arquivos**
    
    ...deve-se usar a biblioteca `@google/genai` Ã© o pacote oficial para a API do Gemini.
    
    A **`@google/generative-ai`** estÃ¡ descontinuado, entÃ£o devo evitar usÃ¡-lo 
    
- O sistema precisa ser capaz de **detectar** quando um prompt ou tarefa exige um desses recursos e, nesses casos, deve **redirecionar automaticamente** a execuÃ§Ã£o para a lib `@google/genai`.
- Isso pode ser feito utilizando um serviÃ§o intermediÃ¡rio (`GeminiSpecialFeaturesService`) que encapsula as chamadas diretas Ã  lib da Google, separando bem da integraÃ§Ã£o normal com o `openai`.

## ğŸ” Similaridade SemÃ¢ntica com Embeddings

* Antes de enviar o comando do usuÃ¡rio Ã  IA, aplique **similaridade semÃ¢ntica** usando embeddings para identificar o(s) grupo(s) de funÃ§Ãµes mais provÃ¡veis
* Os embeddings devem ser prÃ©-gerados e armazenados em um arquivo `.json` local com `vectra`
* Cada funÃ§Ã£o/serviÃ§o deve conter:

  * `id`: identificador Ãºnico
  * `name`: nome descritivo
  * `description`: descriÃ§Ã£o textual da funcionalidade
  * `embedding`: vetor gerado via OpenAI ou equivalente

---

Boa! Esse Ã© um ponto super importante pro seu tipo de projeto â€” onde o usuÃ¡rio pode querer customizar muita coisa (chaves de API, modelo da IA, comportamentos, regras, etc.).

Aqui vai uma **sugestÃ£o de regra extra** para isso, explicando boas prÃ¡ticas de carregamento de configs, que vocÃª pode adicionar no seu conjunto:

---

## âš™ï¸ Carregamento de ConfiguraÃ§Ãµes e API Keys

* Todas as configuraÃ§Ãµes do usuÃ¡rio (ex: chaves de API, modelo de IA, regras especÃ­ficas) devem ser centralizadas em um **arquivo de configuraÃ§Ã£o Ãºnico**, por padrÃ£o `~/.yourcli/config.yaml`.
* Utilize a biblioteca `js-yaml` para ler arquivos `.yaml`, que sÃ£o mais legÃ­veis para o usuÃ¡rio tÃ©cnico.
* Para facilitar manutenÃ§Ã£o e validaÃ§Ã£o, defina um **schema TypeScript** da configuraÃ§Ã£o (usando por exemplo Zod, Yup ou validaÃ§Ã£o manual).
* Exemplo de estrutura recomendada no `.yaml`:

```yaml
openai:
  apiKey: sk-xxxx
  model: gpt-4

vectra:
  storePath: ./data/functions.json

rules:
  allowMultiFunctionCall: true
  defaultLanguage: pt-br

services:
  azureDevOps:
    token: xyz
    orgUrl: https://dev.azure.com/seuorg
```

* A CLI deve carregar e **validar o config no boot**. Caso esteja faltando algo essencial (ex: API key), deve lanÃ§ar erro amigÃ¡vel com instruÃ§Ãµes.
* Caso o usuÃ¡rio deseje customizar o caminho do arquivo de config, permita isso via `--config <path>` ou variÃ¡vel de ambiente `YOURCLI_CONFIG_PATH`.

---

Boa! Emojis em commits sÃ£o uma prÃ¡tica cada vez mais comum pra dar mais clareza e visualidade ao histÃ³rico, ainda mais em projetos dev-first como o seu. Aqui vai uma sugestÃ£o de regra bem direta, prÃ¡tica e fÃ¡cil da IA seguir:

---

## ğŸ’¬ PadrÃ£o de Commits com Emojis

* Todos os commits devem seguir um padrÃ£o semÃ¢ntico e conter um **emoji prefixado** representando o tipo da alteraÃ§Ã£o.
* O formato recomendado Ã©:

```bash
<emoji> <tipo>: <descriÃ§Ã£o curta>
```

* Exemplos:

```bash
âœ¨ feat: adiciona suporte a mÃºltiplos modelos de IA
ğŸ› fix: corrige bug na geraÃ§Ã£o de embeddings
ğŸ“¦ chore: atualiza dependÃªncias do projeto
ğŸ“ docs: adiciona documentaÃ§Ã£o sobre configuraÃ§Ã£o
ğŸš€ perf: melhora o tempo de resposta da CLI
```

* Para consistÃªncia, use os seguintes emojis principais (pode expandir depois):

| Emoji | Tipo       | Uso                                              |
| ----- | ---------- | ------------------------------------------------ |
| âœ¨     | `feat`     | Nova funcionalidade                              |
| ğŸ›    | `fix`      | CorreÃ§Ã£o de bug                                  |
| ğŸ“    | `docs`     | AlteraÃ§Ãµes em documentaÃ§Ã£o                       |
| ğŸ¨    | `style`    | FormataÃ§Ã£o, espaÃ§os, ponto e vÃ­rgula, etc.       |
| â™»ï¸    | `refactor` | RefatoraÃ§Ã£o de cÃ³digo sem alterar funcionalidade |
| ğŸš€    | `perf`     | Melhorias de performance                         |
| âœ…     | `test`     | AdiÃ§Ã£o ou correÃ§Ã£o de testes                     |
| ğŸ“¦    | `chore`    | ManutenÃ§Ã£o, configs, dependÃªncias                |
| ğŸ”§    | `config`   | ConfiguraÃ§Ã£o de ferramentas, linters, etc.       |

---

## ğŸ’¼ Regras de NegÃ³cio EspecÃ­ficas

* A CLI aceitarÃ¡ comandos de texto como entrada
* A IA tomarÃ¡ decisÃµes sobre quais serviÃ§os usar via **Function Calling**
* O sistema deve ser capaz de **executar mÃºltiplas funÃ§Ãµes em sequÃªncia** para montar a resposta final
* Os embeddings das ferramentas devem ser mantidos atualizados e carregados no momento do start
* Cada serviÃ§o precisa:

  * Ter um nome chave
  * Uma descriÃ§Ã£o clara
  * Um embedding correspondente
